/* A recursive-descent parser generated by greg 0.4.4 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct _GREG;
#define YYRULECOUNT 22

# include <stdio.h>

  typedef struct line line;

  struct line
  {
    int	  number;
    int	  length;
    char *text;
  };

  line *lines= 0;
  int   numLines= 0;
  int   pc= -1, epc= -1;
  int   batch= 0;

  int nextline(char *buf, int max);

# define min(x, y) ((x) < (y) ? (x) : (y))

# define YY_INPUT(buf, result, max_size, D)	\
  {						\
    if ((pc >= 0) && (pc < numLines))		\
      {						\
        line *linep= lines+pc++;		\
        result= min(max_size, linep->length);	\
        memcpy(buf, linep->text, result);	\
      }						\
    else					\
      result= nextline(buf, max_size);		\
  }

  union value {
    int		  number;
    char	 *string;
    int		(*binop)(int lhs, int rhs);
  };

# define YYSTYPE union value

  int variables[26];

  void accept(int number, char *line);

  void save(char *name);
  void load(char *name);
  void type(char *name);

  int lessThan(int lhs, int rhs)	{ return lhs <  rhs; }
  int lessEqual(int lhs, int rhs)	{ return lhs <= rhs; }
  int notEqual(int lhs, int rhs)	{ return lhs != rhs; }
  int equalTo(int lhs, int rhs)		{ return lhs == rhs; }
  int greaterEqual(int lhs, int rhs)	{ return lhs >= rhs; }
  int greaterThan(int lhs, int rhs)	{ return lhs >  rhs; }

  int input(void);

  int stack[1024], sp= 0;

  char *help;

  void error(char *fmt, ...);

#ifndef YY_ALLOC
#define YY_ALLOC(N, D) malloc(N)
#endif
#ifndef YY_CALLOC
#define YY_CALLOC(N, S, D) calloc(N, S)
#endif
#ifndef YY_REALLOC
#define YY_REALLOC(B, N, D) realloc(B, N)
#endif
#ifndef YY_FREE
#define YY_FREE free
#endif
#ifndef YY_LOCAL
#define YY_LOCAL(T)     static T
#endif
#ifndef YY_ACTION
#define YY_ACTION(T)    static T
#endif
#ifndef YY_RULE
#define YY_RULE(T)      static T
#endif
#ifndef YY_PARSE
#define YY_PARSE(T)     T
#endif
#ifndef YY_NAME
#define YY_NAME(N) yy##N
#endif
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size, D)		\
  {							\
    int yyc= getchar();					\
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);	\
    yyprintf((stderr, "<%c>", yyc));			\
  }
#endif
#ifndef YY_BEGIN
#define YY_BEGIN        ( G->begin= G->pos, 1)
#endif
#ifndef YY_END
#define YY_END          ( G->end= G->pos, 1)
#endif
#ifdef YY_DEBUG
# ifndef DEBUG_PARSE
#  define DEBUG_PARSE   1
# endif
# ifndef DEBUG_VERBOSE
#  define DEBUG_VERBOSE 2
# endif
# define yyprintf(args)	         if (G->debug & DEBUG_PARSE)         fprintf args
# define yyprintfv(args)         if (G->debug == (DEBUG_PARSE|DEBUG_VERBOSE)) fprintf args
# define yyprintfGcontext        if (G->debug & DEBUG_PARSE)         yyprintcontext(stderr,G->buf+G->pos)
# define yyprintfvGcontext       if (G->debug == (DEBUG_PARSE|DEBUG_VERBOSE)) yyprintcontext(stderr,G->buf+G->pos)
# define yyprintfvTcontext(text) if (G->debug == (DEBUG_PARSE|DEBUG_VERBOSE)) yyprintcontext(stderr,text)
#else
# define yyprintf(args)
# define yyprintfv(args)
# define yyprintfGcontext
# define yyprintfvGcontext
# define yyprintfvTcontext(text)
#endif
#ifndef YYSTYPE
#define YYSTYPE int
#endif
#ifndef YY_XTYPE
#define YY_XTYPE void *
#endif
#ifndef YY_XVAR
#define YY_XVAR yyxvar
#endif

#ifndef YY_STACK_SIZE
#define YY_STACK_SIZE 128
#endif

#ifndef YY_BUFFER_START_SIZE
#define YY_BUFFER_START_SIZE 1024
#endif

#ifndef YY_PART
#define yydata G->data
#define yy G->ss

struct _yythunk; /* forward declaration */
typedef void (*yyaction)(struct _GREG *G, char *yytext, int yyleng, struct _yythunk *thunkpos, YY_XTYPE YY_XVAR);
typedef struct _yythunk { int begin, end;  yyaction  action; const char *name; struct _yythunk *next; } yythunk;

typedef struct _GREG {
  char *buf;
  int buflen;
  int   offset;
  int   pos;
  int   limit;
  char *text;
  int   textlen;
  int   begin;
  int   end;
  yythunk *thunks;
  int   thunkslen;
  int thunkpos;
  YYSTYPE ss;
  YYSTYPE *val;
  YYSTYPE *vals;
  int valslen;
  YY_XTYPE data;
#ifdef YY_DEBUG
  int debug;
#endif
} GREG;

YY_LOCAL(int) yyrefill(GREG *G)
{
  int yyn;
  while (G->buflen - G->pos < 512)
    {
      G->buflen *= 2;
      G->buf= (char*)YY_REALLOC(G->buf, G->buflen, G->data);
    }
  YY_INPUT((G->buf + G->pos), yyn, (G->buflen - G->pos), G->data);
  if (!yyn) return 0;
  G->limit += yyn;
  return 1;
}

YY_LOCAL(int) yymatchDot(GREG *G)
{
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  ++G->pos;
  return 1;
}

#ifdef YY_DEBUG
YY_LOCAL(void) yyprintcontext(FILE *stream, char *s)
{
  char *context = s;
  char *nl = strchr(context, 10);
  if (nl) {
    context = (char*)malloc(nl-s+1);
    strncpy(context, s, nl-s);
    context[nl-s] = '\0'; /* replace nl by 0 */
  }
  fprintf(stream, " @ \"%s\"", context);
  if (nl) free(context);
}
#endif

YY_LOCAL(int) yymatchChar(GREG *G, int c)
{
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  if ((unsigned char)G->buf[G->pos] == c)
    {
      ++G->pos;
      if (c<32) { yyprintf((stderr, "  ok   yymatchChar '0x%x'", c));}
      else      { yyprintf((stderr, "  ok   yymatchChar '%c'", c));}
      yyprintfGcontext;
      yyprintf((stderr, "\n"));
      return 1;
    }
  if (c<32) { yyprintfv((stderr, "  fail yymatchChar '0x%x'", c));}
  else      { yyprintfv((stderr, "  fail yymatchChar '%c'", c));}
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));
  return 0;
}

YY_LOCAL(int) yymatchString(GREG *G, const char *s)
{
  int yysav= G->pos;
  while (*s)
    {
      if (G->pos >= G->limit && !yyrefill(G)) return 0;
      if (G->buf[G->pos] != *s)
        {
          G->pos= yysav;
          return 0;
        }
      ++s;
      ++G->pos;
    }
  return 1;
}

YY_LOCAL(int) yymatchClass(GREG *G, const unsigned char *bits, const char *cclass)
{
  int c;
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  c= (unsigned char)G->buf[G->pos];
  if (bits[c >> 3] & (1 << (c & 7)))
    {
      ++G->pos;
      yyprintf((stderr, "  ok   yymatchClass [%s]", cclass));
      yyprintfGcontext;
      yyprintf((stderr, "\n"));
      return 1;
    }
  yyprintfv((stderr, "  fail yymatchClass [%s]", cclass));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));
  return 0;
}

YY_LOCAL(void) yyDo(GREG *G, yyaction action, int begin, int end, const char *name)
{
  while (G->thunkpos >= G->thunkslen)
    {
      G->thunkslen *= 2;
      G->thunks= (yythunk*)YY_REALLOC(G->thunks, sizeof(yythunk) * G->thunkslen, G->data);
    }
  G->thunks[G->thunkpos].begin=  begin;
  G->thunks[G->thunkpos].end=    end;
  G->thunks[G->thunkpos].action= action;
  G->thunks[G->thunkpos].name= name;
  ++G->thunkpos;
}

YY_LOCAL(int) yyText(GREG *G, int begin, int end)
{
  int yyleng= end - begin;
  if (yyleng <= 0)
    yyleng= 0;
  else
    {
      while (G->textlen < (yyleng + 1))
        {
          G->textlen *= 2;
          G->text= (char*)YY_REALLOC(G->text, G->textlen, G->data);
        }
      memcpy(G->text, G->buf + begin, yyleng);
    }
  G->text[yyleng]= '\0';
  return yyleng;
}

YY_LOCAL(void) yyDone(GREG *G)
{
  int pos;
  for (pos= 0; pos < G->thunkpos; ++pos)
    {
      yythunk *thunk= &G->thunks[pos];
      int yyleng= thunk->end ? yyText(G, thunk->begin, thunk->end) : thunk->begin;
      yyprintf((stderr, "DO [%d] %s", pos, thunk->name));
      yyprintfvTcontext(G->text);
      yyprintf((stderr, "\n"));
      thunk->action(G, G->text, yyleng, thunk, G->data);
    }
  G->thunkpos= 0;
}

YY_LOCAL(void) yyCommit(GREG *G)
{
  if ((G->limit -= G->pos))
    {
      memmove(G->buf, G->buf + G->pos, G->limit);
    }
  G->offset += G->pos;
  G->begin -= G->pos;
  G->end -= G->pos;
  G->pos= G->thunkpos= 0;
}

YY_LOCAL(int) yyAccept(GREG *G, int tp0)
{
  if (tp0)
    {
      fprintf(stderr, "accept denied at %d\n", tp0);
      return 0;
    }
  else
    {
      yyDone(G);
      yyCommit(G);
    }
  return 1;
}

YY_LOCAL(void) yyPush(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)	{
  size_t off = (G->val - G->vals) + count;
  if (off > G->valslen) {
    while (G->valslen < off + 1)
      G->valslen *= 2;
    G->vals= (YYSTYPE*)YY_REALLOC((void *)G->vals, sizeof(YYSTYPE) * G->valslen, G->data);
    G->val= G->vals + off;
  } else {
    G->val += count;
  }
}
YY_LOCAL(void) yyPop(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)	{ G->val -= count; }
YY_LOCAL(void) yySet(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)	{ G->val[count]= G->ss; }

#endif /* YY_PART */

#define YYACCEPT        yyAccept(G, yythunkpos0)

YY_RULE(int) yy_digit(GREG *G); /* 22 */
YY_RULE(int) yy_CLOSE(GREG *G); /* 21 */
YY_RULE(int) yy_OPEN(GREG *G); /* 20 */
YY_RULE(int) yy_SLASH(GREG *G); /* 19 */
YY_RULE(int) yy_STAR(GREG *G); /* 18 */
YY_RULE(int) yy_factor(GREG *G); /* 17 */
YY_RULE(int) yy_MINUS(GREG *G); /* 16 */
YY_RULE(int) yy_term(GREG *G); /* 15 */
YY_RULE(int) yy_PLUS(GREG *G); /* 14 */
YY_RULE(int) yy_COMMA(GREG *G); /* 13 */
YY_RULE(int) yy_string(GREG *G); /* 12 */
YY_RULE(int) yy_EQUAL(GREG *G); /* 11 */
YY_RULE(int) yy_var(GREG *G); /* 10 */
YY_RULE(int) yy_var_list(GREG *G); /* 9 */
YY_RULE(int) yy_relop(GREG *G); /* 8 */
YY_RULE(int) yy_expression(GREG *G); /* 7 */
YY_RULE(int) yy_expr_list(GREG *G); /* 6 */
YY_RULE(int) yy_number(GREG *G); /* 5 */
YY_RULE(int) yy_CR(GREG *G); /* 4 */
YY_RULE(int) yy_statement(GREG *G); /* 3 */
YY_RULE(int) yy__(GREG *G); /* 2 */
YY_RULE(int) yy_line(GREG *G); /* 1 */

YY_ACTION(void) yy_6_relop(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_6_relop"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.binop= equalTo; }\n"));
  yy.binop= equalTo; ;
}
YY_ACTION(void) yy_5_relop(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_5_relop"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.binop= greaterThan; }\n"));
  yy.binop= greaterThan; ;
}
YY_ACTION(void) yy_4_relop(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_4_relop"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.binop= greaterEqual; }\n"));
  yy.binop= greaterEqual; ;
}
YY_ACTION(void) yy_3_relop(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_3_relop"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.binop= lessThan; }\n"));
  yy.binop= lessThan; ;
}
YY_ACTION(void) yy_2_relop(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_2_relop"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.binop= notEqual; }\n"));
  yy.binop= notEqual; ;
}
YY_ACTION(void) yy_1_relop(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_1_relop"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.binop= lessEqual; }\n"));
  yy.binop= lessEqual; ;
}
YY_ACTION(void) yy_1_string(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_1_string"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.string = yytext; }\n"));
  yy.string = yytext; ;
}
YY_ACTION(void) yy_1_number(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_1_number"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.number = atoi(yytext); }\n"));
  yy.number = atoi(yytext); ;
}
YY_ACTION(void) yy_1_var(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_1_var"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.number = yytext[0] - 'a' }\n"));
  yy.number = yytext[0] - 'a' ;
}
YY_ACTION(void) yy_1_factor(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define n G->val[-1]
#define v G->val[-2]
  yyprintf((stderr, "do yy_1_factor"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.number = variables[v.number] }\n"));
  yy.number = variables[v.number] ;
#undef n
#undef v
}
YY_ACTION(void) yy_3_term(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define r G->val[-1]
#define l G->val[-2]
  yyprintf((stderr, "do yy_3_term"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.number = l.number }\n"));
  yy.number = l.number ;
#undef r
#undef l
}
YY_ACTION(void) yy_2_term(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define r G->val[-1]
#define l G->val[-2]
  yyprintf((stderr, "do yy_2_term"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {l.number /= r.number }\n"));
  l.number /= r.number ;
#undef r
#undef l
}
YY_ACTION(void) yy_1_term(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define r G->val[-1]
#define l G->val[-2]
  yyprintf((stderr, "do yy_1_term"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {l.number *= r.number }\n"));
  l.number *= r.number ;
#undef r
#undef l
}
YY_ACTION(void) yy_4_expression(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define r G->val[-1]
#define l G->val[-2]
  yyprintf((stderr, "do yy_4_expression"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy.number = l.number }\n"));
  yy.number = l.number ;
#undef r
#undef l
}
YY_ACTION(void) yy_3_expression(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define r G->val[-1]
#define l G->val[-2]
  yyprintf((stderr, "do yy_3_expression"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {l.number -= r.number }\n"));
  l.number -= r.number ;
#undef r
#undef l
}
YY_ACTION(void) yy_2_expression(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define r G->val[-1]
#define l G->val[-2]
  yyprintf((stderr, "do yy_2_expression"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {l.number += r.number }\n"));
  l.number += r.number ;
#undef r
#undef l
}
YY_ACTION(void) yy_1_expression(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define r G->val[-1]
#define l G->val[-2]
  yyprintf((stderr, "do yy_1_expression"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {l.number = -l.number }\n"));
  l.number = -l.number ;
#undef r
#undef l
}
YY_ACTION(void) yy_2_var_list(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define v G->val[-1]
  yyprintf((stderr, "do yy_2_var_list"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {variables[v.number]= input(); }\n"));
  variables[v.number]= input(); ;
#undef v
}
YY_ACTION(void) yy_1_var_list(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define v G->val[-1]
  yyprintf((stderr, "do yy_1_var_list"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {variables[v.number]= input(); }\n"));
  variables[v.number]= input(); ;
#undef v
}
YY_ACTION(void) yy_5_expr_list(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define e G->val[-1]
  yyprintf((stderr, "do yy_5_expr_list"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {printf(\"\\n\"); }\n"));
  printf("\n"); ;
#undef e
}
YY_ACTION(void) yy_4_expr_list(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define e G->val[-1]
  yyprintf((stderr, "do yy_4_expr_list"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {printf(\"%%d\", e.number); }\n"));
  printf("%d", e.number); ;
#undef e
}
YY_ACTION(void) yy_3_expr_list(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define e G->val[-1]
  yyprintf((stderr, "do yy_3_expr_list"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {printf(\"%%s\", e.string); }\n"));
  printf("%s", e.string); ;
#undef e
}
YY_ACTION(void) yy_2_expr_list(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define e G->val[-1]
  yyprintf((stderr, "do yy_2_expr_list"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {printf(\"%%d\", e.number); }\n"));
  printf("%d", e.number); ;
#undef e
}
YY_ACTION(void) yy_1_expr_list(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define e G->val[-1]
  yyprintf((stderr, "do yy_1_expr_list"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {printf(\"%%s\", e.string); }\n"));
  printf("%s", e.string); ;
#undef e
}
YY_ACTION(void) yy_16_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_16_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {fprintf(stderr, \"%%s\", help); }\n"));
  fprintf(stderr, "%s", help); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_15_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_15_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {system(\"ls *.bas\"); }\n"));
  system("ls *.bas"); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_14_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_14_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {type(s.string); }\n"));
  type(s.string); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_13_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_13_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {load(s.string); }\n"));
  load(s.string); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_12_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_12_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {save(s.string); }\n"));
  save(s.string); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_11_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_11_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {exit(0); }\n"));
  exit(0); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_10_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_10_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {pc= -1;  if (batch) exit(0); }\n"));
  pc= -1;  if (batch) exit(0); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_9_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_9_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {pc= 0; }\n"));
  pc= 0; ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_8_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_8_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {load(s.string);  pc= 0; }\n"));
  load(s.string);  pc= 0; ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_7_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_7_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {int i;  for (i= 0;  i < numLines;  ++i) printf(\"%%5d %%s\", lines[i].number, lines[i].text); }\n"));
  int i;  for (i= 0;  i < numLines;  ++i) printf("%5d %s", lines[i].number, lines[i].text); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_6_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_6_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {while (numLines) accept(lines->number, \"\\n\"); }\n"));
  while (numLines) accept(lines->number, "\n"); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_5_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_5_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {epc= pc;  if ((pc= sp ? stack[--sp] : -1) < 0) error(\"no gosub\"); }\n"));
  epc= pc;  if ((pc= sp ? stack[--sp] : -1) < 0) error("no gosub"); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_4_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_4_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {epc= pc;  if (sp < 1024) stack[sp++]= pc, pc= findLine(e.number); else error(\"too many gosubs\");\n\
\t\t\t\t\t\t\t  if (pc < 0) error(\"no such line\"); }\n"));
  epc= pc;  if (sp < 1024) stack[sp++]= pc, pc= findLine(e.number); else error("too many gosubs");
							  if (pc < 0) error("no such line"); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_3_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_3_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {variables[v.number]= e.number; }\n"));
  variables[v.number]= e.number; ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_2_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_2_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {epc= pc;  if ((pc= findLine(e.number, 0)) < 0) error(\"no such line\"); }\n"));
  epc= pc;  if ((pc= findLine(e.number, 0)) < 0) error("no such line"); ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_1_statement(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
#define v G->val[-2]
#define e G->val[-3]
#define e2 G->val[-4]
#define r G->val[-5]
#define e1 G->val[-6]
  yyprintf((stderr, "do yy_1_statement"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {if (!r.binop(e1.number, e2.number)) G->thunkpos= 0; }\n"));
  if (!r.binop(e1.number, e2.number)) G->thunkpos= 0; ;
#undef s
#undef v
#undef e
#undef e2
#undef r
#undef e1
}
YY_ACTION(void) yy_3_line(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define n G->val[-1]
#define s G->val[-2]
  yyprintf((stderr, "do yy_3_line"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {exit(0); }\n"));
  exit(0); ;
#undef n
#undef s
}
YY_ACTION(void) yy_2_line(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define n G->val[-1]
#define s G->val[-2]
  yyprintf((stderr, "do yy_2_line"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {epc= pc;  error(\"syntax error\"); }\n"));
  epc= pc;  error("syntax error"); ;
#undef n
#undef s
}
YY_ACTION(void) yy_1_line(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define n G->val[-1]
#define s G->val[-2]
  yyprintf((stderr, "do yy_1_line"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {accept(n.number, yytext); }\n"));
  accept(n.number, yytext); ;
#undef n
#undef s
}

YY_RULE(int) yy_digit(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "digit"));
  if (!yymatchClass(G, (const unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", "0-9")) goto l1;
  yyprintf((stderr, "  ok   digit"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l1:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "digit"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_CLOSE(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "CLOSE"));
  if (!yymatchChar(G, ')')) goto l2;
  if (!yy__(G))  goto l2;
  yyprintf((stderr, "  ok   CLOSE"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l2:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "CLOSE"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_OPEN(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "OPEN"));
  if (!yymatchChar(G, '(')) goto l3;
  if (!yy__(G))  goto l3;
  yyprintf((stderr, "  ok   OPEN"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l3:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "OPEN"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_SLASH(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "SLASH"));
  if (!yymatchChar(G, '/')) goto l4;
  if (!yy__(G))  goto l4;
  yyprintf((stderr, "  ok   SLASH"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l4:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "SLASH"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_STAR(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "STAR"));
  if (!yymatchChar(G, '*')) goto l5;
  if (!yy__(G))  goto l5;
  yyprintf((stderr, "  ok   STAR"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l5:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "STAR"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_factor(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "factor"));

  {  int yypos7= G->pos, yythunkpos7= G->thunkpos;  if (!yy_var(G))  goto l8;
  yyDo(G, yySet, -2, 0, "yySet");
  yyDo(G, yy_1_factor, G->begin, G->end, "yy_1_factor");
  goto l7;
  l8:;	  G->pos= yypos7; G->thunkpos= yythunkpos7;  if (!yy_number(G))  goto l9;
  yyDo(G, yySet, -1, 0, "yySet");
  goto l7;
  l9:;	  G->pos= yypos7; G->thunkpos= yythunkpos7;  if (!yy_OPEN(G))  goto l6;
  if (!yy_expression(G))  goto l6;
  if (!yy_CLOSE(G))  goto l6;

  }
  l7:;	  yyprintf((stderr, "  ok   factor"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 2, 0, "yyPop");
  return 1;
  l6:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "factor"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_MINUS(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "MINUS"));
  if (!yymatchChar(G, '-')) goto l10;
  if (!yy__(G))  goto l10;
  yyprintf((stderr, "  ok   MINUS"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l10:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "MINUS"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_term(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "term"));
  if (!yy_factor(G))  goto l11;
  yyDo(G, yySet, -2, 0, "yySet");

  l12:;	
  {  int yypos13= G->pos, yythunkpos13= G->thunkpos;
  {  int yypos14= G->pos, yythunkpos14= G->thunkpos;  if (!yy_STAR(G))  goto l15;
  if (!yy_factor(G))  goto l15;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_1_term, G->begin, G->end, "yy_1_term");
  goto l14;
  l15:;	  G->pos= yypos14; G->thunkpos= yythunkpos14;  if (!yy_SLASH(G))  goto l13;
  if (!yy_factor(G))  goto l13;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_2_term, G->begin, G->end, "yy_2_term");

  }
  l14:;	  goto l12;
  l13:;	  G->pos= yypos13; G->thunkpos= yythunkpos13;
  }  yyDo(G, yy_3_term, G->begin, G->end, "yy_3_term");
  yyprintf((stderr, "  ok   term"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 2, 0, "yyPop");
  return 1;
  l11:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "term"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_PLUS(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "PLUS"));
  if (!yymatchChar(G, '+')) goto l16;
  if (!yy__(G))  goto l16;
  yyprintf((stderr, "  ok   PLUS"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l16:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "PLUS"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_COMMA(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "COMMA"));
  if (!yymatchChar(G, ',')) goto l17;
  if (!yy__(G))  goto l17;
  yyprintf((stderr, "  ok   COMMA"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l17:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "COMMA"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_string(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "string"));
  if (!yymatchChar(G, '"')) goto l18;
  yyText(G, G->begin, G->end);  if (!(YY_BEGIN)) goto l18;
  l19:;	
  {  int yypos20= G->pos, yythunkpos20= G->thunkpos;  if (!yymatchClass(G, (const unsigned char *)"\377\377\377\377\373\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377", "^\\\"")) goto l20;
  goto l19;
  l20:;	  G->pos= yypos20; G->thunkpos= yythunkpos20;
  }  yyText(G, G->begin, G->end);  if (!(YY_END)) goto l18;  if (!yymatchChar(G, '"')) goto l18;
  if (!yy__(G))  goto l18;
  yyDo(G, yy_1_string, G->begin, G->end, "yy_1_string");
  yyprintf((stderr, "  ok   string"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l18:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "string"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_EQUAL(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "EQUAL"));
  if (!yymatchChar(G, '=')) goto l21;
  if (!yy__(G))  goto l21;
  yyprintf((stderr, "  ok   EQUAL"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l21:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "EQUAL"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_var(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "var"));
  yyText(G, G->begin, G->end);  if (!(YY_BEGIN)) goto l22;  if (!yymatchClass(G, (const unsigned char *)"\000\000\000\000\000\000\000\000\000\000\000\000\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", "a-z")) goto l22;
  yyText(G, G->begin, G->end);  if (!(YY_END)) goto l22;  if (!yy__(G))  goto l22;
  yyDo(G, yy_1_var, G->begin, G->end, "yy_1_var");
  yyprintf((stderr, "  ok   var"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l22:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "var"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_var_list(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 1, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "var_list"));
  if (!yy_var(G))  goto l23;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_1_var_list, G->begin, G->end, "yy_1_var_list");

  l24:;	
  {  int yypos25= G->pos, yythunkpos25= G->thunkpos;  if (!yy_COMMA(G))  goto l25;
  if (!yy_var(G))  goto l25;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_2_var_list, G->begin, G->end, "yy_2_var_list");
  goto l24;
  l25:;	  G->pos= yypos25; G->thunkpos= yythunkpos25;
  }  yyprintf((stderr, "  ok   var_list"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 1, 0, "yyPop");
  return 1;
  l23:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "var_list"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_relop(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "relop"));

  {  int yypos27= G->pos, yythunkpos27= G->thunkpos;  if (!yymatchString(G, "<=")) goto l28;
  if (!yy__(G))  goto l28;
  yyDo(G, yy_1_relop, G->begin, G->end, "yy_1_relop");
  goto l27;
  l28:;	  G->pos= yypos27; G->thunkpos= yythunkpos27;  if (!yymatchString(G, "<>")) goto l29;
  if (!yy__(G))  goto l29;
  yyDo(G, yy_2_relop, G->begin, G->end, "yy_2_relop");
  goto l27;
  l29:;	  G->pos= yypos27; G->thunkpos= yythunkpos27;  if (!yymatchChar(G, '<')) goto l30;
  if (!yy__(G))  goto l30;
  yyDo(G, yy_3_relop, G->begin, G->end, "yy_3_relop");
  goto l27;
  l30:;	  G->pos= yypos27; G->thunkpos= yythunkpos27;  if (!yymatchString(G, ">=")) goto l31;
  if (!yy__(G))  goto l31;
  yyDo(G, yy_4_relop, G->begin, G->end, "yy_4_relop");
  goto l27;
  l31:;	  G->pos= yypos27; G->thunkpos= yythunkpos27;  if (!yymatchChar(G, '>')) goto l32;
  if (!yy__(G))  goto l32;
  yyDo(G, yy_5_relop, G->begin, G->end, "yy_5_relop");
  goto l27;
  l32:;	  G->pos= yypos27; G->thunkpos= yythunkpos27;  if (!yymatchChar(G, '=')) goto l26;
  if (!yy__(G))  goto l26;
  yyDo(G, yy_6_relop, G->begin, G->end, "yy_6_relop");

  }
  l27:;	  yyprintf((stderr, "  ok   relop"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l26:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "relop"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_expression(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "expression"));

  {  int yypos34= G->pos, yythunkpos34= G->thunkpos;
  {  int yypos36= G->pos, yythunkpos36= G->thunkpos;  if (!yy_PLUS(G))  goto l36;
  goto l37;
  l36:;	  G->pos= yypos36; G->thunkpos= yythunkpos36;
  }
  l37:;	  if (!yy_term(G))  goto l35;
  yyDo(G, yySet, -2, 0, "yySet");
  goto l34;
  l35:;	  G->pos= yypos34; G->thunkpos= yythunkpos34;  if (!yy_MINUS(G))  goto l33;
  if (!yy_term(G))  goto l33;
  yyDo(G, yySet, -2, 0, "yySet");
  yyDo(G, yy_1_expression, G->begin, G->end, "yy_1_expression");

  }
  l34:;	
  l38:;	
  {  int yypos39= G->pos, yythunkpos39= G->thunkpos;
  {  int yypos40= G->pos, yythunkpos40= G->thunkpos;  if (!yy_PLUS(G))  goto l41;
  if (!yy_term(G))  goto l41;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_2_expression, G->begin, G->end, "yy_2_expression");
  goto l40;
  l41:;	  G->pos= yypos40; G->thunkpos= yythunkpos40;  if (!yy_MINUS(G))  goto l39;
  if (!yy_term(G))  goto l39;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_3_expression, G->begin, G->end, "yy_3_expression");

  }
  l40:;	  goto l38;
  l39:;	  G->pos= yypos39; G->thunkpos= yythunkpos39;
  }  yyDo(G, yy_4_expression, G->begin, G->end, "yy_4_expression");
  yyprintf((stderr, "  ok   expression"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 2, 0, "yyPop");
  return 1;
  l33:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "expression"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_expr_list(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 1, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "expr_list"));

  {  int yypos43= G->pos, yythunkpos43= G->thunkpos;
  {  int yypos45= G->pos, yythunkpos45= G->thunkpos;  if (!yy_string(G))  goto l46;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_1_expr_list, G->begin, G->end, "yy_1_expr_list");
  goto l45;
  l46:;	  G->pos= yypos45; G->thunkpos= yythunkpos45;  if (!yy_expression(G))  goto l43;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_2_expr_list, G->begin, G->end, "yy_2_expr_list");

  }
  l45:;	  goto l44;
  l43:;	  G->pos= yypos43; G->thunkpos= yythunkpos43;
  }
  l44:;	
  l47:;	
  {  int yypos48= G->pos, yythunkpos48= G->thunkpos;  if (!yy_COMMA(G))  goto l48;

  {  int yypos49= G->pos, yythunkpos49= G->thunkpos;  if (!yy_string(G))  goto l50;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_3_expr_list, G->begin, G->end, "yy_3_expr_list");
  goto l49;
  l50:;	  G->pos= yypos49; G->thunkpos= yythunkpos49;  if (!yy_expression(G))  goto l48;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_4_expr_list, G->begin, G->end, "yy_4_expr_list");

  }
  l49:;	  goto l47;
  l48:;	  G->pos= yypos48; G->thunkpos= yythunkpos48;
  }
  {  int yypos51= G->pos, yythunkpos51= G->thunkpos;  if (!yy_COMMA(G))  goto l52;
  goto l51;
  l52:;	  G->pos= yypos51; G->thunkpos= yythunkpos51;
  {  int yypos53= G->pos, yythunkpos53= G->thunkpos;  if (!yy_COMMA(G))  goto l53;
  goto l42;
  l53:;	  G->pos= yypos53; G->thunkpos= yythunkpos53;
  }  yyDo(G, yy_5_expr_list, G->begin, G->end, "yy_5_expr_list");

  }
  l51:;	  yyprintf((stderr, "  ok   expr_list"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 1, 0, "yyPop");
  return 1;
  l42:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "expr_list"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_number(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "number"));
  yyText(G, G->begin, G->end);  if (!(YY_BEGIN)) goto l54;  if (!yy_digit(G))  goto l54;

  l55:;	
  {  int yypos56= G->pos, yythunkpos56= G->thunkpos;  if (!yy_digit(G))  goto l56;
  goto l55;
  l56:;	  G->pos= yypos56; G->thunkpos= yythunkpos56;
  }  yyText(G, G->begin, G->end);  if (!(YY_END)) goto l54;  if (!yy__(G))  goto l54;
  yyDo(G, yy_1_number, G->begin, G->end, "yy_1_number");
  yyprintf((stderr, "  ok   number"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l54:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "number"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_CR(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "CR"));

  {  int yypos58= G->pos, yythunkpos58= G->thunkpos;  if (!yymatchChar(G, '\n')) goto l59;
  goto l58;
  l59:;	  G->pos= yypos58; G->thunkpos= yythunkpos58;  if (!yymatchChar(G, '\r')) goto l60;
  goto l58;
  l60:;	  G->pos= yypos58; G->thunkpos= yythunkpos58;  if (!yymatchString(G, "\r\n")) goto l57;

  }
  l58:;	  yyprintf((stderr, "  ok   CR"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l57:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "CR"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_statement(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 6, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "statement"));

  {  int yypos62= G->pos, yythunkpos62= G->thunkpos;  if (!yymatchString(G, "print")) goto l63;
  if (!yy__(G))  goto l63;
  if (!yy_expr_list(G))  goto l63;
  goto l62;
  l63:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "if")) goto l64;
  if (!yy__(G))  goto l64;
  if (!yy_expression(G))  goto l64;
  yyDo(G, yySet, -6, 0, "yySet");
  if (!yy_relop(G))  goto l64;
  yyDo(G, yySet, -5, 0, "yySet");
  if (!yy_expression(G))  goto l64;
  yyDo(G, yySet, -4, 0, "yySet");
  yyDo(G, yy_1_statement, G->begin, G->end, "yy_1_statement");
  if (!yymatchString(G, "then")) goto l64;
  if (!yy__(G))  goto l64;
  if (!yy_statement(G))  goto l64;
  goto l62;
  l64:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "goto")) goto l65;
  if (!yy__(G))  goto l65;
  if (!yy_expression(G))  goto l65;
  yyDo(G, yySet, -3, 0, "yySet");
  yyDo(G, yy_2_statement, G->begin, G->end, "yy_2_statement");
  goto l62;
  l65:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "input")) goto l66;
  if (!yy__(G))  goto l66;
  if (!yy_var_list(G))  goto l66;
  goto l62;
  l66:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "let")) goto l67;
  if (!yy__(G))  goto l67;
  if (!yy_var(G))  goto l67;
  yyDo(G, yySet, -2, 0, "yySet");
  if (!yy_EQUAL(G))  goto l67;
  if (!yy_expression(G))  goto l67;
  yyDo(G, yySet, -3, 0, "yySet");
  yyDo(G, yy_3_statement, G->begin, G->end, "yy_3_statement");
  goto l62;
  l67:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "gosub")) goto l68;
  if (!yy__(G))  goto l68;
  if (!yy_expression(G))  goto l68;
  yyDo(G, yySet, -3, 0, "yySet");
  yyDo(G, yy_4_statement, G->begin, G->end, "yy_4_statement");
  goto l62;
  l68:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "return")) goto l69;
  if (!yy__(G))  goto l69;
  yyDo(G, yy_5_statement, G->begin, G->end, "yy_5_statement");
  goto l62;
  l69:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "clear")) goto l70;
  if (!yy__(G))  goto l70;
  yyDo(G, yy_6_statement, G->begin, G->end, "yy_6_statement");
  goto l62;
  l70:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "list")) goto l71;
  if (!yy__(G))  goto l71;
  yyDo(G, yy_7_statement, G->begin, G->end, "yy_7_statement");
  goto l62;
  l71:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "run")) goto l72;
  if (!yy__(G))  goto l72;
  if (!yy_string(G))  goto l72;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_8_statement, G->begin, G->end, "yy_8_statement");
  goto l62;
  l72:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "run")) goto l73;
  if (!yy__(G))  goto l73;
  yyDo(G, yy_9_statement, G->begin, G->end, "yy_9_statement");
  goto l62;
  l73:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "end")) goto l74;
  if (!yy__(G))  goto l74;
  yyDo(G, yy_10_statement, G->begin, G->end, "yy_10_statement");
  goto l62;
  l74:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "rem")) goto l75;
  if (!yy__(G))  goto l75;

  l76:;	
  {  int yypos77= G->pos, yythunkpos77= G->thunkpos;
  {  int yypos78= G->pos, yythunkpos78= G->thunkpos;  if (!yy_CR(G))  goto l78;
  goto l77;
  l78:;	  G->pos= yypos78; G->thunkpos= yythunkpos78;
  }  if (!yymatchDot(G)) goto l77;  goto l76;
  l77:;	  G->pos= yypos77; G->thunkpos= yythunkpos77;
  }  goto l62;
  l75:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;
  {  int yypos80= G->pos, yythunkpos80= G->thunkpos;  if (!yymatchString(G, "bye")) goto l81;
  goto l80;
  l81:;	  G->pos= yypos80; G->thunkpos= yythunkpos80;  if (!yymatchString(G, "quit")) goto l82;
  goto l80;
  l82:;	  G->pos= yypos80; G->thunkpos= yythunkpos80;  if (!yymatchString(G, "exit")) goto l79;

  }
  l80:;	  if (!yy__(G))  goto l79;
  yyDo(G, yy_11_statement, G->begin, G->end, "yy_11_statement");
  goto l62;
  l79:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "save")) goto l83;
  if (!yy__(G))  goto l83;
  if (!yy_string(G))  goto l83;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_12_statement, G->begin, G->end, "yy_12_statement");
  goto l62;
  l83:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "load")) goto l84;
  if (!yy__(G))  goto l84;
  if (!yy_string(G))  goto l84;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_13_statement, G->begin, G->end, "yy_13_statement");
  goto l62;
  l84:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "type")) goto l85;
  if (!yy__(G))  goto l85;
  if (!yy_string(G))  goto l85;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_14_statement, G->begin, G->end, "yy_14_statement");
  goto l62;
  l85:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "dir")) goto l86;
  if (!yy__(G))  goto l86;
  yyDo(G, yy_15_statement, G->begin, G->end, "yy_15_statement");
  goto l62;
  l86:;	  G->pos= yypos62; G->thunkpos= yythunkpos62;  if (!yymatchString(G, "help")) goto l61;
  if (!yy__(G))  goto l61;
  yyDo(G, yy_16_statement, G->begin, G->end, "yy_16_statement");

  }
  l62:;	  yyprintf((stderr, "  ok   statement"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 6, 0, "yyPop");
  return 1;
  l61:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "statement"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy__(GREG *G)
{  yyprintfv((stderr, "%s\n", "_"));

  l88:;	
  {  int yypos89= G->pos, yythunkpos89= G->thunkpos;  if (!yymatchClass(G, (const unsigned char *)"\000\002\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", " \\t")) goto l89;
  goto l88;
  l89:;	  G->pos= yypos89; G->thunkpos= yythunkpos89;
  }  yyprintf((stderr, "  ok   _"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
}
YY_RULE(int) yy_line(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "line"));

  {  int yypos91= G->pos, yythunkpos91= G->thunkpos;  if (!yy__(G))  goto l92;
  if (!yy_statement(G))  goto l92;
  yyDo(G, yySet, -2, 0, "yySet");
  if (!yy_CR(G))  goto l92;
  goto l91;
  l92:;	  G->pos= yypos91; G->thunkpos= yythunkpos91;  if (!yy__(G))  goto l93;
  if (!yy_number(G))  goto l93;
  yyDo(G, yySet, -1, 0, "yySet");
  yyText(G, G->begin, G->end);  if (!(YY_BEGIN)) goto l93;
  l94:;	
  {  int yypos95= G->pos, yythunkpos95= G->thunkpos;
  {  int yypos96= G->pos, yythunkpos96= G->thunkpos;  if (!yy_CR(G))  goto l96;
  goto l95;
  l96:;	  G->pos= yypos96; G->thunkpos= yythunkpos96;
  }  if (!yymatchDot(G)) goto l95;  goto l94;
  l95:;	  G->pos= yypos95; G->thunkpos= yythunkpos95;
  }  if (!yy_CR(G))  goto l93;
  yyText(G, G->begin, G->end);  if (!(YY_END)) goto l93;  yyDo(G, yy_1_line, G->begin, G->end, "yy_1_line");
  goto l91;
  l93:;	  G->pos= yypos91; G->thunkpos= yythunkpos91;  if (!yy__(G))  goto l97;
  if (!yy_CR(G))  goto l97;
  goto l91;
  l97:;	  G->pos= yypos91; G->thunkpos= yythunkpos91;  if (!yy__(G))  goto l98;
  yyText(G, G->begin, G->end);  if (!(YY_BEGIN)) goto l98;
  l99:;	
  {  int yypos100= G->pos, yythunkpos100= G->thunkpos;
  {  int yypos101= G->pos, yythunkpos101= G->thunkpos;  if (!yy_CR(G))  goto l101;
  goto l100;
  l101:;	  G->pos= yypos101; G->thunkpos= yythunkpos101;
  }  if (!yymatchDot(G)) goto l100;  goto l99;
  l100:;	  G->pos= yypos100; G->thunkpos= yythunkpos100;
  }  if (!yy_CR(G))  goto l98;
  yyText(G, G->begin, G->end);  if (!(YY_END)) goto l98;  yyDo(G, yy_2_line, G->begin, G->end, "yy_2_line");
  goto l91;
  l98:;	  G->pos= yypos91; G->thunkpos= yythunkpos91;  if (!yy__(G))  goto l90;

  {  int yypos102= G->pos, yythunkpos102= G->thunkpos;  if (!yymatchDot(G)) goto l102;  goto l90;
  l102:;	  G->pos= yypos102; G->thunkpos= yythunkpos102;
  }  yyDo(G, yy_3_line, G->begin, G->end, "yy_3_line");

  }
  l91:;	  yyprintf((stderr, "  ok   line"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 2, 0, "yyPop");
  return 1;
  l90:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "line"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}

#ifndef YY_PART

typedef int (*yyrule)(GREG *G);

YY_PARSE(int) YY_NAME(parse_from)(GREG *G, yyrule yystart)
{
  int yyok;
  if (!G->buflen)
    {
      G->buflen= YY_BUFFER_START_SIZE;
      G->buf= (char*)YY_ALLOC(G->buflen, G->data);
      G->textlen= YY_BUFFER_START_SIZE;
      G->text= (char*)YY_ALLOC(G->textlen, G->data);
      G->thunkslen= YY_STACK_SIZE;
      G->thunks= (yythunk*)YY_ALLOC(sizeof(yythunk) * G->thunkslen, G->data);
      G->valslen= YY_STACK_SIZE;
      G->vals= (YYSTYPE*)YY_ALLOC(sizeof(YYSTYPE) * G->valslen, G->data);
      G->begin= G->end= G->pos= G->limit= G->thunkpos= 0;
    }
  G->pos = 0;
  G->begin= G->end= G->pos;
  G->thunkpos= 0;
  G->val= G->vals;
  yyok= yystart(G);
  if (yyok) yyDone(G);
  yyCommit(G);
  return yyok;
  (void)yyrefill;
  (void)yymatchDot;
  (void)yymatchChar;
  (void)yymatchString;
  (void)yymatchClass;
  (void)yyDo;
  (void)yyText;
  (void)yyDone;
  (void)yyCommit;
  (void)yyAccept;
  (void)yyPush;
  (void)yyPop;
  (void)yySet;
}

YY_PARSE(int) YY_NAME(parse)(GREG *G)
{
  return YY_NAME(parse_from)(G, yy_line);
}

YY_PARSE(void) YY_NAME(init)(GREG *G)
{
    memset(G, 0, sizeof(GREG));
}
YY_PARSE(void) YY_NAME(deinit)(GREG *G)
{
    if (G->buf) YY_FREE(G->buf);
    if (G->text) YY_FREE(G->text);
    if (G->thunks) YY_FREE(G->thunks);
    if (G->vals) YY_FREE((void*)G->vals);
}
YY_PARSE(GREG *) YY_NAME(parse_new)(YY_XTYPE data)
{
  GREG *G = (GREG *)YY_CALLOC(1, sizeof(GREG), G->data);
  G->data = data;
  return G;
}

YY_PARSE(void) YY_NAME(parse_free)(GREG *G)
{
  YY_NAME(deinit)(G);
  YY_FREE(G);
}

#endif


#include <unistd.h>
#include <stdarg.h>

char *help=
  "print <num>|<string> [, <num>|<string> ...] [,]\n"
  "if <expr> <|<=|<>|=|>=|> <expr> then <stmt>\n"
  "input <var> [, <var> ...]     let <var> = <expr>\n"
  "goto <expr>                   gosub <expr>\n"
  "end                           return\n"
  "list                          clear\n"
  "run [\"filename\"]              rem <comment...>\n"
  "dir                           type \"filename\"\n"
  "save \"filename\"               load \"filename\"\n"
  "bye|quit|exit                 help\n"
  ;

void error(char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  if (epc > 0)
    fprintf(stderr, "\nline %d: %s", lines[epc-1].number, lines[epc-1].text);
  else
    fprintf(stderr, "\n");
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  va_end(ap);
  epc= pc= -1;
}

#ifdef USE_READLINE
# include <readline/readline.h>
# include <readline/history.h>
#endif

int nextline(char *buf, int max)
{
  pc= -1;
  if (batch) exit(0);
  if (isatty(fileno(stdin)))
    {
#    ifdef USE_READLINE
      char *line= readline(">");
      if (line)
	{
	  int len= strlen(line);
	  if (len >= max) len= max - 1;
	  strncpy(buf, line, len);
	  (buf)[len]= '\n';
	  add_history(line);
	  free(line);
	  return len + 1;
	}
      else
	{
	  printf("\n");
	  return 0;
	}
#    endif
      putchar('>');
      fflush(stdout);
    }
  return fgets(buf, max, stdin) ? strlen(buf) : 0;
}

int maxLines= 0;

int findLine(int n, int create)
{
  int lo= 0, hi= numLines - 1;
  while (lo <= hi)
    {
      int mid= (lo + hi) / 2, lno= lines[mid].number;
      if (lno > n)
	hi= mid - 1;
      else if (lno < n)
	lo= mid + 1;
      else
	return mid;
    }
  if (create)
    {
      if (numLines == maxLines)
	{
	  maxLines *= 2;
	  lines= realloc(lines, sizeof(line) * maxLines);
	}
      if (lo < numLines)
	memmove(lines + lo + 1, lines + lo, sizeof(line) * (numLines - lo));
      ++numLines;
      lines[lo].number= n;
      lines[lo].text= 0;
      return lo;
    }
  return -1;
}

void accept(int n, char *s)
{
  if (s[0] < 32)	/* delete */
    {
      int lno= findLine(n, 0);
      if (lno >= 0)
	{
	  if (lno < numLines - 1)
	    memmove(lines + lno, lines + lno + 1, sizeof(line) * (numLines - lno - 1));
	  --numLines;
	}
    }
  else			/* insert */
    {
      int lno= findLine(n, 1);
      if (lines[lno].text) free(lines[lno].text);
      lines[lno].length= strlen(s);
      lines[lno].text= strdup(s);
    }
}

char *extend(char *name)
{
  static char path[1024];
  int len= strlen(name);
  sprintf(path, "%s%s", name, (((len > 4) && !strcasecmp(".bas", name + len - 4)) ? "" : ".bas"));
  return path;
}

void save(char *name)
{
  FILE *f= fopen(name= extend(name), "w");
  if (!f)
    perror(name);
  else
    {
      int i;
      for (i= 0;  i < numLines;  ++i)
	fprintf(f, "%d %s", lines[i].number, lines[i].text);
      fclose(f);
    }
}

void load(char *name)
{
  FILE *f= fopen(name= extend(name), "r");
  if (!f)
    perror(name);
  else
    {
      int  lineNumber;
      char lineText[1024];
      while ((1 == fscanf(f, " %d ", &lineNumber)) && fgets(lineText, sizeof(lineText), f))
	accept(lineNumber, lineText);
      fclose(f);
    }
}

void type(char *name)
{
  FILE *f= fopen(name= extend(name), "r");
  if (!f)
    perror(name);
  else
    {
      int  c, d;
      while ((c= getc(f)) >= 0)
	putchar(d= c);
      fclose(f);
      if ('\n' != d && '\r' != d) putchar('\n');
    }
}

int input(void)
{
  char line[32];
  fgets(line, sizeof(line), stdin);
  return atoi(line);
}

int main(int argc, char **argv)
{
  lines= malloc(sizeof(line) * (maxLines= 32));
  numLines= 0;

  if (argc > 1)
    {
      batch= 1;
      while (argc-- > 1)
	load(*++argv);
      pc= 0;
    }

  GREG g;
  yyinit(&g);
  while (!feof(stdin))
    yyparse(&g);
  yydeinit(&g);
  return 0;
}

